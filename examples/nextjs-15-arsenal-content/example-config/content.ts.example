// src/lib/arsenal/content.ts
// Type-safe content loading functions

import { readFile, readdir } from 'fs/promises'
import { join } from 'path'
import matter from 'gray-matter'
import { BaseArsenalMetadata } from './types'

/**
 * Load a single Arsenal resource by type and slug
 */
export async function loadArsenalResource<T extends BaseArsenalMetadata>(
  resourceType: string,
  slug: string
): Promise<{ metadata: T; content: string } | null> {
  try {
    const filePath = join(
      process.cwd(),
      'content',
      'arsenal',
      resourceType + 's',  // Note: directory name is plural
      `${slug}.mdx`
    )
    
    const fileContent = await readFile(filePath, 'utf-8')
    const { data, content } = matter(fileContent)
    
    // Validate required fields
    if (!data.slug || !data.title || !data.resourceType) {
      console.error(`Invalid metadata in ${slug}.mdx: missing required fields`)
      return null
    }
    
    // Verify slug matches filename
    if (data.slug !== slug) {
      console.error(`Slug mismatch in ${slug}.mdx: "${data.slug}" != "${slug}"`)
      return null
    }
    
    return {
      metadata: data as T,
      content,
    }
  } catch (error) {
    console.error(`Error loading resource ${resourceType}/${slug}:`, error)
    return null
  }
}

/**
 * Load all resources of a given type
 */
export async function loadAllArsenalResources<T extends BaseArsenalMetadata>(
  resourceType: string
): Promise<T[]> {
  try {
    const dirPath = join(
      process.cwd(),
      'content',
      'arsenal',
      resourceType + 's'
    )
    
    const files = await readdir(dirPath)
    const mdxFiles = files.filter(file => file.endsWith('.mdx'))
    
    const resources: T[] = []
    
    for (const file of mdxFiles) {
      const slug = file.replace('.mdx', '')
      const resource = await loadArsenalResource<T>(resourceType, slug)
      
      if (resource) {
        resources.push(resource.metadata)
      }
    }
    
    // Sort by date (newest first)
    return resources.sort((a, b) => 
      new Date(b.dateUpdated).getTime() - new Date(a.dateUpdated).getTime()
    )
  } catch (error) {
    console.error(`Error loading resources of type ${resourceType}:`, error)
    return []
  }
}

/**
 * Get resources by tag
 */
export async function loadResourcesByTag<T extends BaseArsenalMetadata>(
  resourceType: string,
  tag: string
): Promise<T[]> {
  const allResources = await loadAllArsenalResources<T>(resourceType)
  return allResources.filter(resource => 
    resource.tags.includes(tag)
  )
}

/**
 * Get resources by status
 */
export async function loadResourcesByStatus<T extends BaseArsenalMetadata>(
  resourceType: string,
  status: 'available' | 'coming-soon' | 'beta' | 'deprecated'
): Promise<T[]> {
  const allResources = await loadAllArsenalResources<T>(resourceType)
  return allResources.filter(resource => 
    resource.status === status
  )
}

/**
 * Search resources by title or description
 */
export async function searchResources<T extends BaseArsenalMetadata>(
  resourceType: string,
  query: string
): Promise<T[]> {
  const allResources = await loadAllArsenalResources<T>(resourceType)
  const lowerQuery = query.toLowerCase()
  
  return allResources.filter(resource =>
    resource.title.toLowerCase().includes(lowerQuery) ||
    resource.description.toLowerCase().includes(lowerQuery) ||
    resource.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
  )
}

/**
 * Get all unique tags for a resource type
 */
export async function getAllTags(resourceType: string): Promise<string[]> {
  const allResources = await loadAllArsenalResources(resourceType)
  const tagSet = new Set<string>()
  
  allResources.forEach(resource => {
    resource.tags.forEach(tag => tagSet.add(tag))
  })
  
  return Array.from(tagSet).sort()
}

/**
 * Get resource count by type
 */
export async function getResourceCount(resourceType: string): Promise<number> {
  const resources = await loadAllArsenalResources(resourceType)
  return resources.length
}

/**
 * Validate MDX frontmatter
 */
export function validateMetadata(data: any, slug: string): string[] {
  const errors: string[] = []
  
  const required = [
    'slug', 'title', 'description', 'resourceType', 
    'status', 'dateAdded', 'dateUpdated', 'tags'
  ]
  
  for (const field of required) {
    if (!data[field]) {
      errors.push(`Missing required field: ${field}`)
    }
  }
  
  if (data.slug !== slug) {
    errors.push(`Slug mismatch: "${data.slug}" != "${slug}"`)
  }
  
  if (!Array.isArray(data.tags) || data.tags.length === 0) {
    errors.push('Tags must be a non-empty array')
  }
  
  const validStatuses = ['available', 'coming-soon', 'beta', 'deprecated']
  if (!validStatuses.includes(data.status)) {
    errors.push(`Invalid status: ${data.status}`)
  }
  
  return errors
}
